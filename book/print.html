<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>RTeasy-Online</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/custom.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Tutorial</li><li class="chapter-item expanded "><a href="tutorial/lang/index.html"><strong aria-hidden="true">1.</strong> The Register Transfer Language RTeasy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/lang/declarations.html"><strong aria-hidden="true">1.1.</strong> Declarations</a></li><li class="chapter-item expanded "><a href="tutorial/lang/algorithm.html"><strong aria-hidden="true">1.2.</strong> Algorithm</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/lang/micro-operations.html"><strong aria-hidden="true">1.2.1.</strong> Micro Operations</a></li><li class="chapter-item expanded "><a href="tutorial/lang/expressions.html"><strong aria-hidden="true">1.2.2.</strong> Expressions</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="tutorial/ide/index.html"><strong aria-hidden="true">2.</strong> IDE User Guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/ide/editing-mode.html"><strong aria-hidden="true">2.1.</strong> Editing Mode</a></li><li class="chapter-item expanded "><a href="tutorial/ide/simulation-mode.html"><strong aria-hidden="true">2.2.</strong> Simulation Mode</a></li><li class="chapter-item expanded "><a href="tutorial/ide/vhdl-export.html"><strong aria-hidden="true">2.3.</strong> VHDL Export</a></li></ol></li><li class="chapter-item expanded "><a href="tutorial/cli/index.html"><strong aria-hidden="true">3.</strong> CLI User Guide</a></li><li class="chapter-item expanded "><a href="tutorial/examples/index.html"><strong aria-hidden="true">4.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/examples/easy-multiplier.html"><strong aria-hidden="true">4.1.</strong> Easy Multiplier</a></li><li class="chapter-item expanded "><a href="tutorial/examples/register-register-machine.html"><strong aria-hidden="true">4.2.</strong> Register-Register-Machine</a></li></ol></li><li class="chapter-item expanded "><a href="tutorial/advanced/index.html"><strong aria-hidden="true">5.</strong> Advanced</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/advanced/eval-expressions.html"><strong aria-hidden="true">5.1.</strong> Evaluation of Expressions</a></li><li class="chapter-item expanded "><a href="tutorial/advanced/memory-file-format.html"><strong aria-hidden="true">5.2.</strong> Memory File Format</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Compiler Error Index</li><li class="chapter-item expanded "><a href="compiler-error-index/errors.html"><strong aria-hidden="true">6.</strong> Errors</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="appendix.html">Appendix</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">RTeasy-Online</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>RTeasy-Online is a development environment for the register transfer language RTeasy. With RTeasy it is possible to design and simulate register transfer programs. Moreover, execution unit and control unit can be extracted from the algorithms. Among other things, this makes it possible to export an RTeasy program to VHDL.</p>
<h2 id="tutorial"><a class="header" href="#tutorial">Tutorial</a></h2>
<p>The tutorial is the main part of this book. It starts with an <a href="tutorial/lang">explanation of the language</a>. After that there is a user guide for the <a href="tutorial/ide">IDE</a> and for the <a href="tutorial/cli">CLI</a>. This is followed by a few practical application <a href="tutorial/examples">examples</a> and additional <a href="tutorial/advanced">advanced/in-depth material</a>.</p>
<p>If you are already familiar with RTeasy or RT code in general, you may want to jump straight to the <a href="tutorial/examples">examples</a> to see what can be done with RTeasy.</p>
<h2 id="compiler-error-index"><a class="header" href="#compiler-error-index">Compiler Error Index</a></h2>
<p>The <a href="compiler-error-index/errors.html">compiler error index</a> serves as an overview of all possible errors that can occur during compilation.</p>
<h2 id="code-blocks"><a class="header" href="#code-blocks">Code Blocks</a></h2>
<p>You will find code blocks in many places in this book. They may contain several different icons for interacting with them:</p>
<table><thead><tr><th>Icon</th><th>Description</th></tr></thead><tbody>
<tr><td><i class="fa fa-copy"></i></td><td>Copies the code block into your local clipboard.</td></tr>
<tr><td><i class="fa fa-eye"></i></td><td>Toggle visibility of &quot;hidden&quot; lines. Some examples will hide lines that are not particularly relevant to what is being illustrated.</td></tr>
</tbody></table>
<p>Here is an example:</p>
<pre><code class="language-rteasy"><span class="boring">declare register X(7:0) # &lt;-- hidden by default
</span><span class="boring">
</span># Increment X by 1
X &lt;- X + 1;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-register-transfer-language-rteasy"><a class="header" href="#the-register-transfer-language-rteasy">The Register Transfer Language RTeasy</a></h1>
<p>A register transfer language (RT language) is used to describe the hardware using register operations. The following basic pattern is used for the operations:</p>
<pre><code>Z &lt;- f(X_1, X_2, ..., X_m)
</code></pre>
<p>where <code>Z</code>, <code>X_1</code>, <code>X_2</code>, ... , <code>X_m</code> represent identifiers for registers and the function <code>f</code> describes the operation. The result is then stored in <code>Z</code>.</p>
<p>An RTeasy program consists of a set of declarations followed by the actual algorithm. All declarations must be placed in the header of the program. Besides registers, buses, register arrays and memories can be declared. These are all explained in more detail in the next section.</p>
<p>An important concept in RTeasy is the difference between the clocked and the unclocked items. While registers, register arrays and memories are clocked, buses are unclocked. This means that values assigned to a register are only available in the next clock cycle. In contrast, values assigned to a bus are yet available in the same and only in this clock cycle.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="declarations"><a class="header" href="#declarations">Declarations</a></h1>
<p>Before the actual algorithm, all items must first be defined. A declaration is composed of a <code>declare</code> followed by the type of the item, e.g. <code>register</code>, and finally the list of items you want to declare, separated by commas. All names may only contain uppercase letters, digits or underscores, whereby the first character may not be a digit.</p>
<h2 id="registers"><a class="header" href="#registers">Registers</a></h2>
<p>Declare two registers <code>R</code> and <code>C</code>. Register <code>R</code> is 8 bits wide and ranges from 7 (MSB) to 0 (LSB). The register <code>C</code> is 1 bit wide, with the bit at position 0.</p>
<pre><code class="language-rteasy">declare register R(7:0), C
</code></pre>
<h2 id="buses"><a class="header" href="#buses">Buses</a></h2>
<p>Declare two buses <code>B</code> and <code>SECOND_BUS</code>. Bus <code>B</code> is 8 bits wide and ranges from 7 (MSB) to 0 (LSB). The bus <code>SECOND_BUS</code> is 1 bit wide, with the bit at position 5.</p>
<pre><code class="language-rteasy">declare bus B(7:0), SECOND_BUS(5)
</code></pre>
<h2 id="register-arrays"><a class="header" href="#register-arrays">Register Arrays</a></h2>
<p>Declare a register array named <code>ARR</code>. As with registers and buses, a bit range can be specified. The length of the register array is specified in brackets. The length must be a power of two.</p>
<pre><code class="language-rteasy">declare register array ARR(7:0)[4]
</code></pre>
<p>Register arrays may be read no more than twice and written no more than once per execution path and cycle.</p>
<h2 id="memories"><a class="header" href="#memories">Memories</a></h2>
<p>Declare a memory named <code>MEM</code>. Memories require two registers, whereby the first is the address register and the second is the data register. So in this case <code>AR</code> is the address register and <code>DR</code> is the data register. Thus the memory is of size 2^16 = 64 KByte and 1 byte wide.</p>
<pre><code class="language-rteasy">declare register AR(15:0), DR(7:0)
declare memory MEM(AR, DR)
</code></pre>
<h2 id="inputsoutputs"><a class="header" href="#inputsoutputs">Inputs/Outputs</a></h2>
<p>Declare an input <code>IN</code> and an output <code>OUT</code>. As far as the execution is concerned, outputs behave exactly as registers do. Inputs behave exactly as buses do, except that they are read-only and are not reset between clock cycles.</p>
<pre><code class="language-rteasy">declare input IN(7:0)
declare output OUT(7:0)
</code></pre>
<p>Inputs and outputs define the interface of a program. The inputs and outputs become input and output ports respectively in the VHDL export.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="algorithm"><a class="header" href="#algorithm">Algorithm</a></h1>
<p>The declarations are followed by the actual algorithm. The algorithm consists of a list of states that are executed sequentially. A state represents a clock cycle in which several <em>micro operations</em> are executed in parallel. Each state is terminated by a semicolon.</p>
<pre><code class="language-rteasy"><span class="boring">declare register A(3:0), B(3:0), REG(3:0)
</span><span class="boring">
</span># A simple state with two micro operations executed in parallel.
A &lt;- A + 1, B &lt;- B - 1;

# Another state with only one micro operation.
REG &lt;- A and B;
</code></pre>
<h2 id="label"><a class="header" href="#label">Label</a></h2>
<p>In addition to the micro operations, a state can receive a label to which it can be jumped to:</p>
<pre><code class="language-rteasy"><span class="boring">declare register A(3:0)
</span><span class="boring">
</span># A state with the label MY_LABEL.
MY_LABEL: A &lt;- A + 1;

# ...

# Resume execution at MY_LABEL
goto MY_LABEL;
</code></pre>
<h2 id="conditional-branch"><a class="header" href="#conditional-branch">Conditional Branch</a></h2>
<p>Since registers are clocked, it is not possible to jump in one cycle depending on the result of a register assignment. Instead two cycles are needed. For this purpose, a state can have a conditional branch separated by the pipe symbol. After the pipe, all assignments have already taken place. The conditional branch may only contain if, switch and goto operations. With this, it is possible in some cases to save a clock cycle by writing:</p>
<pre><code class="language-rteasy"><span class="boring">declare register COUNTER(7:0)
</span><span class="boring">
</span>LOOP:  nop; # do something
CHECK: COUNTER &lt;- COUNTER + 1 | if COUNTER &lt; 20 then goto LOOP fi;
</code></pre>
<p>instead of:</p>
<pre><code class="language-rteasy"><span class="boring">declare register COUNTER(7:0)
</span><span class="boring">
</span>LOOP:  nop; # do something
INC:   COUNTER &lt;- COUNTER + 1;
CHECK: if COUNTER &lt; 20 then goto LOOP fi;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="micro-operations"><a class="header" href="#micro-operations">Micro Operations</a></h1>
<p>The micro operations are the building blocks of the algorithm. Besides the unconditional operations (assignment, no operation and read/write) there are jumps (goto) and conditional operations (if and switch).</p>
<h2 id="assignment"><a class="header" href="#assignment">Assignment</a></h2>
<p>Use assignments to store the result of an expression in a register, bus, output or register array. Assignments are written as <code>Target &lt;- Expression</code>. The target can be either a single item or a concatenation. So for example <code>X(3:0).Z(1:0)</code> would be a six bit wide target. When assigned, the two least significant bits from the expression would end up in <code>Z</code> and the four bits above would end up in <code>X</code>. A concatenation can contain either only clocked or only unclocked items.</p>
<p>When assigning registers, outputs and buses, individual bits can be addressed as just shown. In contrast, register arrays can only be assigned as a whole. So you can write <code>ARR[2] &lt;- EXPR</code> but not <code>ARR(3:0)[2] &lt;- EXPR</code>. The reason for this is that the access to a register in an array is always exhaustive. When writing all bits must be written and when reading all bits must be read. Since single bits can be simply ignored when reading, it is possible to specify a bit range when reading but not when writing.</p>
<pre><code class="language-rteasy">declare register X(3:0), Y(3:0)

# Store the result of 2 + 2 in X
X &lt;- 2 + 2;

# Store 0b10010011 into X.Y (=&gt; X = 0b1001, Y = 0b0011)
X.Y &lt;- 0b10010011;
</code></pre>
<h2 id="no-operation"><a class="header" href="#no-operation">No Operation</a></h2>
<p>The <code>nop</code> operation will not trigger any operation and can be used to have an empty state.</p>
<pre><code class="language-rteasy">nop;
</code></pre>
<h2 id="readwrite"><a class="header" href="#readwrite">Read/Write</a></h2>
<p>The read and write operations are available for operating on memories. Both operations take the name of the memory as an argument, e.g. <code>read MEM</code>. When reading, the value currently stored in the memory at the position of the address register is written to the data register. In the case of writing, the process is exactly the opposite: The value from the data register is written into the memory.</p>
<pre><code class="language-rteasy"><span class="boring">declare register AR(3:0), DR(3:0)
</span><span class="boring">declare memory MEM(AR, DR)
</span><span class="boring">
</span># Read value at position 4
AR &lt;- 4;
read MEM;

# Write (value + 1) back to the memory
DR &lt;- DR + 1;
write MEM;
</code></pre>
<h2 id="assert"><a class="header" href="#assert">Assert</a></h2>
<p>The assert operation checks if an expression (with a size of one bit) is one or zero. If the expression evaluates to zero, the assert fails and the simulator will stop immediately and highlight the failed assert.</p>
<p>The assert operation is intended as a tool for development and is therefore only executed in the simulator. It will not execute if the program gets compiled to VHDL.</p>
<pre><code class="language-rteasy"><span class="boring">declare bus BUS(3:0)
</span><span class="boring">
</span>assert 5 &gt; 2; # passes
assert BUS = 2, BUS &lt;- 2; # passes
</code></pre>
<pre><code class="language-rteasy should_fail">assert 2 = 3; # fails
</code></pre>
<h2 id="goto"><a class="header" href="#goto">Goto</a></h2>
<p>The goto operation takes a label and can be used to resume the execution at a different state than the following one.</p>
<pre><code class="language-rteasy"><span class="boring">declare register A, B
</span><span class="boring">
</span>START: A &lt;- 0, B &lt;- 1, goto SKIP;

A &lt;- B; # &lt;-- This is never executed

SKIP: nop; # do something
END: goto START;
</code></pre>
<h2 id="if"><a class="header" href="#if">If</a></h2>
<p>The if operation checks a single condition, which can be either one or zero, and executes the if or else branch accordingly. Syntactically, the else branch is optional. If it is missing a simple <code>nop</code> is used instead. Both branches can contain any number of micro operations, just like a state. Thus, it is also possible to nest if operations.</p>
<pre><code class="language-rteasy"><span class="boring">declare register A(3:0), B(3:0), C(3:0), D(3:0), COUNT(3:0)
</span><span class="boring">
</span># If/else
if COUNT = 0 then
    A &lt;- 0, B &lt;- 0
else
    A &lt;- 1
fi;

# Nested if
if A = 0 and B = 0 then
    C &lt;- 0, if D &gt; 1 then D &lt;- 0 fi
fi;
</code></pre>
<h2 id="switch"><a class="header" href="#switch">Switch</a></h2>
<p>The switch operation checks an expression against various values. The expression must have a fixed size. This requirement is necessary to have a well defined size in which to evaluate. Fixed size expression are: comparisons, concatenations, registers, buses, register arrays and bit strings.</p>
<p>The values used in the case clauses can be literals or constant expressions. Constant expression are: literals, concatenations only containing constants and terms only containing constants.</p>
<p>In addition to the case clauses, there must always be exactly one default clause.</p>
<pre><code class="language-rteasy"><span class="boring">declare register A(3:0), B(3:0), C(3:0), D(3:0)
</span><span class="boring">
</span>switch A.D(2) {            # match against a fixed size expression
    case 0: B &lt;- 2, C &lt;- 2 # case clause 0
    case 1: nop            # case clause 1
    case 1 + 1: C &lt;- 3     # case clause 2 (1 + 1)
    default: goto END      # default clause
};
<span class="boring">
</span><span class="boring">END:
</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expressions"><a class="header" href="#expressions">Expressions</a></h1>
<p>Expressions appear in assignments, asserts, and as conditions.
Besides literals, registers and buses there is the possibility to form concatenations and terms.</p>
<p>When evaluating expressions, expressions of different sizes are automatically adjusted by zero extending by default.
However, if you want for example a register to be interpreted as signed, you can use the sign extend operator (see further below) to extend with the sign bit instead.
What the exact rules are when evaluating expressions can be seen in <a href="tutorial/lang/../advanced/eval-expressions.html">Evaluation of Expressions</a>.</p>
<h2 id="literals"><a class="header" href="#literals">Literals</a></h2>
<h3 id="decimal"><a class="header" href="#decimal">Decimal</a></h3>
<pre><code class="language-rteasy"><span class="boring">declare register X(7:0)
</span><span class="boring">
</span>X &lt;- 12;
X &lt;- 00000012; # leading zeros are stripped
</code></pre>
<h3 id="binary"><a class="header" href="#binary">Binary</a></h3>
<p>Binary literals are prefixed with <code>0b</code>/<code>0B</code> (or with <code>%</code> for compatibility with older versions).</p>
<pre><code class="language-rteasy"><span class="boring">declare register X(7:0)
</span><span class="boring">
</span>X &lt;-     0b110011;
X &lt;-     0B110011;
X &lt;-      %110011;
X &lt;- 0b0000110011; # leading zeros are stripped
</code></pre>
<h3 id="hexadecimal"><a class="header" href="#hexadecimal">Hexadecimal</a></h3>
<p>Hexadecimal literals are prefixed with <code>0x</code>/<code>0X</code> (or with <code>$</code> for compatibility with older versions).</p>
<pre><code class="language-rteasy"><span class="boring">declare register X(7:0)
</span><span class="boring">
</span>X &lt;-     0xfa;
X &lt;-     0XfA;
X &lt;-      $fa;
X &lt;- 0x0000fa; # leading zeros are stripped
</code></pre>
<h3 id="bit-strings"><a class="header" href="#bit-strings">Bit Strings</a></h3>
<p>Bit strings are a sequence of zeros and ones delimited by double quotes. They work pretty much the same as normal binary numbers. The only difference is that they have a fixed size unlike other literals. All other literals ignore leading zeros and are always equivalent to the shortest binary representation of themselves.</p>
<p>The main use case for bit strings is for use in concatenations (see further below) where all parts must have a well defined size.</p>
<pre><code class="language-rteasy"><span class="boring">declare register X(7:0)
</span><span class="boring">
</span>X &lt;- &quot;01010&quot;;
</code></pre>
<h2 id="registersbuses"><a class="header" href="#registersbuses">Registers/Buses</a></h2>
<p>Registers and buses can be used simply by name. Individual bits can be accessed by specifying a bit range.</p>
<pre><code class="language-rteasy"><span class="boring">declare register X(7:0)
</span>declare register REG(7:0)
declare bus BUS(7:0)

X &lt;- REG;
X &lt;- BUS;

X &lt;- REG(4:2); # Access a subrange
X &lt;- BUS(4);   # Access a single bit
</code></pre>
<h2 id="register-arrays-1"><a class="header" href="#register-arrays-1">Register Arrays</a></h2>
<p>Using register arrays works similiar to using registers. In addition to the name, an index must be specified, which is itself an expression.
Individual bits can be accessed by specifying a bit range.</p>
<p>In addition, care must be taken that register arrays may be read no more than twice once per execution path and cycle.</p>
<pre><code class="language-rteasy"><span class="boring">declare register X(7:0)
</span>declare register IDX(1:0)
declare register array ARR(7:0)[4]

X &lt;- ARR[0];       # Read at index 0
X &lt;- ARR[IDX + 1]; # Use an expression as the index

X &lt;- ARR[3](4:2);  # Access a subrange
X &lt;- ARR[3](4);    # Access a single bit
</code></pre>
<h2 id="concatenations"><a class="header" href="#concatenations">Concatenations</a></h2>
<p>Concatenations can be composed of registers, buses, register arrays and bit strings. The individual values are simply concatenated bit by bit.</p>
<pre><code class="language-rteasy"><span class="boring">declare register X(31:0)
</span>declare register REG(7:0)
declare bus BUS(7:0)
declare register array ARR(7:0)[4]

X &lt;- REG.&quot;001100&quot;.BUS(2);
X &lt;- &quot;01&quot;.ARR[3].REG(3:1);
</code></pre>
<h2 id="terms"><a class="header" href="#terms">Terms</a></h2>
<p>Unary terms are written as <code>OPERATOR EXPRESSION</code> and binary terms are written as <code>EXPRESSION OPERATOR EXPRESSION</code>.</p>
<pre><code class="language-rteasy"><span class="boring">declare register X(15:0)
</span>declare register REG(7:0)
declare bus BUS(7:0)

X &lt;- neg REG;
X &lt;- REG + 1;
X &lt;- not BUS.&quot;1&quot; + 42;
</code></pre>
<p>The following table gives an overview of all operators. Operators with higher precedence are executed before operators with lower precedence. Precedence comes before associativity.</p>
<table><thead><tr><th>Precedence</th><th>Operator</th><th>Associativity</th><th>Individual operators</th></tr></thead><tbody>
<tr><td>10</td><td>Unary Sign</td><td>right-to-left</td><td><code>- ... </code></td></tr>
<tr><td>10</td><td>Unary Negation</td><td>right-to-left</td><td><code>neg ... </code></td></tr>
<tr><td>9</td><td>Sign Extend</td><td>right-to-left</td><td><code>sxt ... </code></td></tr>
<tr><td>8</td><td>Addition</td><td>left-to-right</td><td><code>... + ...</code></td></tr>
<tr><td>8</td><td>Subtraction</td><td>left-to-right</td><td><code>... - ...</code></td></tr>
<tr><td>7</td><td>Less Than</td><td>left-to-right</td><td><code>... &lt; ...</code></td></tr>
<tr><td>7</td><td>Less Than Or Equal</td><td>left-to-right</td><td><code>... &lt;= ...</code></td></tr>
<tr><td>7</td><td>Greater Than</td><td>left-to-right</td><td><code>... &gt; ...</code></td></tr>
<tr><td>7</td><td>Greater Than Or Equal</td><td>left-to-right</td><td><code>... &gt;= ...</code></td></tr>
<tr><td>6</td><td>Equality</td><td>left-to-right</td><td><code>... = ...</code></td></tr>
<tr><td>6</td><td>Inequality</td><td>left-to-right</td><td><code>... &lt;&gt; ...</code></td></tr>
<tr><td>5</td><td>Bitwise NOT</td><td>right-to-left</td><td><code>not ...</code></td></tr>
<tr><td>4</td><td>Bitwise NAND</td><td>left-to-right</td><td><code>... nand ...</code></td></tr>
<tr><td>3</td><td>Bitwise AND</td><td>left-to-right</td><td><code>... and ...</code></td></tr>
<tr><td>2</td><td>Bitwise NOR</td><td>left-to-right</td><td><code>... nor ...</code></td></tr>
<tr><td>1</td><td>Bitwise OR</td><td>left-to-right</td><td><code>... or ...</code></td></tr>
<tr><td>0</td><td>Bitwise XOR</td><td>left-to-right</td><td><code>... xor ...</code></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ide-user-guide"><a class="header" href="#ide-user-guide">IDE User Guide</a></h1>
<p>The <a href="tutorial/ide/../../..">RTeasy-Online IDE</a> has two different modes. On the one hand there is the editing mode, in which the program is developed. On the other hand there is the simulation mode, where you can execute the program and display the register, bus, register array and memory contents. In this mode, you cannot modify the program. In both modes all views can be moved around freely.</p>
<p>At the start you are always in the editing mode.</p>
<h2 id="toolbar"><a class="header" href="#toolbar">Toolbar</a></h2>
<p>At the top you can see the toolbar. With File and Edit classic IDE functions like loading/saving the file or undo/redo can be done. Under Run you can find the same functionality that is available in the second row in the center of the screen. The first button (<img src="tutorial/ide/../../images/icons/build.svg" alt="Build" />) builds the program and, if successful, takes you to the simulation mode. The remaining four are used to control the simulation and are disabled in edit mode.</p>
<hr />
<p><img src="tutorial/ide/../../images/toolbar.png" alt="Toolbar" /></p>
<h2 id="options-dialog"><a class="header" href="#options-dialog">Options Dialog</a></h2>
<p>The options dialog is accessible via the toolbar: <code>File -&gt; Options...</code>.</p>
<p>Here you can set the clock rate for the simulation. Furthermore, it is possible to reset changes to the layout.</p>
<hr />
<p><img src="tutorial/ide/../../images/options-dialog.png" alt="Options Dialog" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="editing-mode"><a class="header" href="#editing-mode">Editing Mode</a></h1>
<p>Besides syntax highlighting, the code editor supports autocompletion and code snippets for frequently used constructs like switch-case operations. At the same time, all errors, if any, are displayed live on the right side.</p>
<p>Each error is associated with an error code that can be clicked and leads to the <a href="tutorial/ide/../../compiler-error-index/errors.html">compiler error index</a> that explains the errors in more detail.</p>
<hr />
<p><img src="tutorial/ide/../../images/ide-editing-mode.png" alt="The RTeasy-Online IDE in the editing mode." /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simulation-mode"><a class="header" href="#simulation-mode">Simulation Mode</a></h1>
<p>This mode is for the simulating and testing the program. In addition to the code, the signals and the current state can be viewed here.
The state view displays the register, bus, register array and memory contents. During simulation, both the code and the state view provide visual hints.</p>
<p>The buttons at the top center are now all operable. From left to right they let you return to the editing mode (<img src="tutorial/ide/../../images/icons/code.svg" alt="Code" />), start/stop the simulation (<img src="tutorial/ide/../../images/icons/run.svg" alt="Run" />/<img src="tutorial/ide/../../images/icons/stop.svg" alt="Stop" />), reset the simulation (<img src="tutorial/ide/../../images/icons/reset.svg" alt="Reset" />), make a step (execute the next state) (<img src="tutorial/ide/../../images/icons/step.svg" alt="Step" />) and make a micro step (execute the next micro step) (<img src="tutorial/ide/../../images/icons/micro-step.svg" alt="Micro Step" />).</p>
<hr />
<p><img src="tutorial/ide/../../images/ide-simulation-mode.png" alt="The RTeasy-Online IDE in the simulation mode." /></p>
<h2 id="code-view"><a class="header" href="#code-view">Code View</a></h2>
<p>During simulation, the code view provide visual hints.
When executing a micro step, the current micro step is highlighted in yellow. Conditions are highlighted either green or red, respectively, whether they evaluate to true or false. For conditions, this highlighting becomes transparent as soon as the next micro operation is executed.
When executing a step, the complete current step is highlighted in yellow.</p>
<h2 id="state-view"><a class="header" href="#state-view">State View</a></h2>
<p>The state view displays the register, bus, register array and memory contents. In addition, the cycle count is displayed in the upper right corner.</p>
<p>Via several dropdowns it is possible to select the base in which the values are presented. The dropdown in the upper left corner serves as the global default setting. This setting can then be inherited elsewhere (Inherit) or overwritten locally (BIN/DEC/HEX).</p>
<p>During simulation, the state view provide visual hints.
When executing with micro steps, writes to registers are represented by an arrow, with the value that is assigned after the clock cycle on the right-hand side.
After executing a complete step, values that have changed are highlighted in yellow.</p>
<h3 id="register-array-and-memory-view"><a class="header" href="#register-array-and-memory-view">Register Array and Memory View</a></h3>
<p>Register array and memory views are not shown by default and can be opened by clicking the <em>Content</em> button next to their name in the state view.</p>
<p>Both allow you to set a base in which the values are presented. The content is divided over several pages.
For memories it is possible to jump to a specific address via <em>Goto</em>. You can load a memory state or save the current state via <em>Load</em> and <em>Save</em>.</p>
<hr />
<p><img src="tutorial/ide/../../images/reg-array-and-memory.png" alt="Register Array and Memory View" /></p>
<h2 id="signals-view"><a class="header" href="#signals-view">Signals View</a></h2>
<p>The signals view shows the condition signals and control signals of a resulting execution unit and control unit respectively.</p>
<h2 id="breakpoints"><a class="header" href="#breakpoints">Breakpoints</a></h2>
<p>By clicking on the line numbers it is possible to set or remove breakpoints. If the simulation is now started via the play button, it will pause as soon as a breakpoint is reached. For an example, see below. The execution was paused just before <code>X &lt;- X + 1</code>.</p>
<hr />
<p><img src="tutorial/ide/../../images/breakpoint.png" alt="Breakpoint Example" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vhdl-export"><a class="header" href="#vhdl-export">VHDL Export</a></h1>
<p>The VHDL export is accessible via the toolbar: <code>File -&gt; Export to VHDL...</code>.</p>
<p>If your code does not contain any errors you should see a dialog like below. Note: Some errors occur only during VHDL export. So you might see errors even though you can simulate your code without problems.</p>
<hr />
<p><img src="tutorial/ide/../../images/vhdl-export-dialog.png" alt="VHDL Export Dialog" /></p>
<h2 id="module-name"><a class="header" href="#module-name">Module name</a></h2>
<p>Choose a module name for the export. The generated VHDL code will contain the entities <code>CU_my_module</code> (control unit) and <code>EU_my_module</code> (execution unit). If not specified, <code>my_module</code> will be used.</p>
<h2 id="memories-1"><a class="header" href="#memories-1">Memories</a></h2>
<p>For each memory in your code you can select a memory file with which this memory is pre-initialized. The size of the address and data register must match exactly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cli-user-guide"><a class="header" href="#cli-user-guide">CLI User Guide</a></h1>
<p>The CLI (command-line interface) is a alternative frontend to the graphical user interface. It currently supports the help, check, gen-vhdl and test commands. The help command displays a general help page or help for a subcommand. The check command checks if the given RTeasy program is syntactically and semantically valid. The gen-vhdl command can be used to export an RTeasy program to VHDL. The test command allows automatic testing of an RTeasy program against a test file.</p>
<p>The CLI can be downloaded from <a href="https://github.com/iti-luebeck/rteasy-online/releases">GitHub</a>.</p>
<h2 id="help"><a class="header" href="#help">Help</a></h2>
<p>Run <code>rt-easy-cli --help</code> to display the message below, or run, for example, <code>rt-easy-cli test --help</code> to get more detailed information about a specific subcommand.</p>
<pre><code class="language-bash">rt-easy-cli 0.1.0
rt easy cli

USAGE:
    rt-easy-cli [FLAGS] &lt;SUBCOMMAND&gt;

FLAGS:
    -h, --help       Prints help information
        --no-ansi    Disable ansi colors
    -V, --version    Prints version information

SUBCOMMANDS:
    check       Check the rt file
    gen-vhdl    Generate VHDL code
    help        Prints this message or the help of the given subcommand(s)
    test        Test the rt file
</code></pre>
<h2 id="check"><a class="header" href="#check">Check</a></h2>
<p>The check command checks if the given RTeasy program is syntactically and semantically valid. The program to be checked is passed as a file path.</p>
<pre><code class="language-shell">$ rt-easy-cli check path/to/my/code.rt
</code></pre>
<h2 id="generate-vhdl-code"><a class="header" href="#generate-vhdl-code">Generate VHDL Code</a></h2>
<p>The gen-vhdl command can be used to export an RTeasy program to VHDL. The first argument is the path to the RTeasy program and the second argument is the path where the generated VHDL code is to be saved.</p>
<pre><code class="language-shell">$ rt-easy-cli gen-vhdl path/to/my/code.rt path/to/generated.vhdl
</code></pre>
<p>The name of the generated VHDL module can be specified via <code>--module-name &lt;module-name&gt;</code>, otherwise the name of the VHDL file is used. In addition, memories can be pre-initialized via <code>--memories MEM_A path/to/MEM_A.rtmem MEM_B path/to/MEM_B.rtmem</code> (see <a href="tutorial/cli/../advanced/memory-file-format.html">Memory File Format</a>).</p>
<h2 id="test"><a class="header" href="#test">Test</a></h2>
<p>The test command allows automatic testing of an RTeasy program against a test file. The first argument is the path to the RTeasy program and the second argument is the path to the test file.</p>
<pre><code class="language-shell">$ rt-easy-cli test path/to/my/code.rt path/to/my/test_file.rtt
</code></pre>
<p>The test only has access to the interface of the program, meaning only to the inputs and ouputs. The syntax and semantic of a test file is explained in the following example:</p>
<pre><code class="language-rteasy ignore"># Test files support line comments prefixed by a `#`.
# All statements are newline terminated and are simply executed sequentially.

# Step: Execute one or more steps on the simulator.
# If no amount is given, one step is performed. Examples:
step
step 5
step 1
step 2

# Micro step: Execute one or more micro steps on the simulator.
# If no amount is given, one micro step is performed. Examples:
microStep
microStep 5
microStep 1
microStep 2

# Run: Run the simulator to the end or until a breakpoint is reached.
run

# Reset: Reset the simulator and all breakpoints.
reset

# Set/Remove breakpoint: Set or remove a breakpoint at the given label. Examples:
set breakpoint MY_LABEL
set breakpoint LABEL_B
remove breakpoint MY_LABEL

# Set input: Writing to inputs is similar to assigning in RTeasy programs.
# The expression can use all inputs and outputs of the program. Examples:
MY_INPUT &lt;- 42 + -1
MY_INPUT &lt;- MY_OUTPUT(3:0).&quot;1&quot;

# Assert: Assert statements work the same way as in RTeasy with the restriction
# that only inputs and ouputs can be accessed. Examples:
assert MY_OUTPUT = 28
assert 1
assert MY_INPUT + 4 = MY_OUTPUT
</code></pre>
<h3 id="example-usage"><a class="header" href="#example-usage">Example Usage</a></h3>
<p><strong>Task</strong>: Find the sum of two numbers in the two's complement. For the calculation 8 bit wide registers are to be used. The two summands are to be read in via an input named <code>IN</code> in the first and second clock cycle respectively. After termination the result is to be available in the output <code>OUT</code>.</p>
<p><strong>Test file</strong>:</p>
<pre><code class="language-rteasy ignore"># Test various additions. Always reset after each test case.

# Test 8 + 3 = 11
IN &lt;- 8
step
IN &lt;- 3
run
assert OUT = 11
reset

# Test 255 + 1 = 0
IN &lt;- 255
step
IN &lt;- 1
run
assert OUT = 0
reset
</code></pre>
<p><strong>Possible valid solutions:</strong></p>
<pre><code class="language-rteasy">declare input IN(7:0)
declare output OUT(7:0)

OUT &lt;- IN;
OUT &lt;- OUT + IN;
</code></pre>
<pre><code class="language-rteasy">declare input IN(7:0)
declare output OUT(7:0)
declare register A(7:0), B(7:0)

A &lt;- IN;
B &lt;- IN;
OUT &lt;- A + B;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<p>The following sections contain practical application examples.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="easy-multiplier"><a class="header" href="#easy-multiplier">Easy Multiplier</a></h1>
<h2 id="task"><a class="header" href="#task">Task</a></h2>
<p>The goal is to design a simple multiplier for two integer, positive fixed point numbers.
The two factors are to be read in via one input. The result is to be
output via one output. Both factors must not be greater than 255.</p>
<h2 id="flowchart"><a class="header" href="#flowchart">Flowchart</a></h2>
<p>The following flowchart should illustrate the idea of the solution. <code>FACTOR</code> and <code>A</code> are the two factors that are read from the input. <code>RES</code> is the result register.</p>
<p><img src="tutorial/examples/../../images/easy-multiplier-flowchart.svg" alt="Flowchart" /></p>
<h2 id="draft-program"><a class="header" href="#draft-program">Draft Program</a></h2>
<p>Open the RTeasy-Online IDE. At startup you are automatically in editing mode. If there is already code, it must be removed first.</p>
<p>Now the following program code can be entered into the editor. The flowchart has already shown that the registers <code>A</code>, <code>FACTOR</code> and <code>RES</code> are needed. Since the factors are maximum 255, two 8-bit registers, as well as a 16-bit result register are sufficient:</p>
<pre><code class="language-rteasy">declare register A(7:0), FACTOR(7:0), RES(15:0)
</code></pre>
<p>For the input and the output of the program one input and one output are needed, where the input has the size of the factors (8-bit) and the output has the size of the result (16-bit):</p>
<pre><code class="language-rteasy"><span class="boring">declare register A(7:0), FACTOR(7:0), RES(15:0)
</span>declare input IN(7:0)
declare output OUT(15:0)
</code></pre>
<p>The program starts ideally with the initialization of the registers, whereby the label <code>BEGIN</code> is only given here for the sake of clarity. Here in the first cycle the value for <code>A</code> and then in the second cycle the value for <code>FACTOR</code> is read in via the input <code>IN</code>:</p>
<pre><code class="language-rteasy"><span class="boring">declare register A(7:0), FACTOR(7:0), RES(15:0)
</span><span class="boring">declare input IN(7:0)
</span><span class="boring">declare output OUT(15:0)
</span><span class="boring">
</span>BEGIN:
A &lt;- IN, RES &lt;- 0;
FACTOR &lt;- IN;
</code></pre>
<p>A loop follows which checks whether the value in <code>FACTOR</code> is zero. If yes, the result is written to <code>OUT</code>, if not, <code>FACTOR</code> is decremented and the value from <code>A</code> is added to <code>RES</code>:</p>
<pre><code class="language-rteasy"><span class="boring">declare register A(7:0), FACTOR(7:0), RES(15:0)
</span><span class="boring">declare input IN(7:0)
</span><span class="boring">declare output OUT(15:0)
</span><span class="boring">
</span><span class="boring">BEGIN:
</span><span class="boring">A &lt;- IN, RES &lt;- 0;
</span><span class="boring">FACTOR &lt;- IN;
</span><span class="boring">
</span>LOOP:
if FACTOR = 0 then
    OUT &lt;- RES
else
    RES &lt;- RES + A,
    FACTOR &lt;- FACTOR - 1,
    goto LOOP
fi;
</code></pre>
<p>The complete program should now look something like this:</p>
<pre><code class="language-rteasy">declare register A(7:0), FACTOR(7:0), RES(15:0)
declare input IN(7:0)
declare output OUT(15:0)

BEGIN:
A &lt;- IN, RES &lt;- 0;
FACTOR &lt;- IN;

LOOP:
if FACTOR = 0 then
    OUT &lt;- RES
else
    RES &lt;- RES + A,
    FACTOR &lt;- FACTOR - 1,
    goto LOOP
fi;
</code></pre>
<h2 id="simulation"><a class="header" href="#simulation">Simulation</a></h2>
<p>Via the build button (<img src="tutorial/examples/../../images/icons/build.svg" alt="Build" />) you can now switch to simulation mode.</p>
<p>Now you can write the first factor of the multiplication into the input <code>IN</code> in the opened state view. If you then click on the step button (<img src="tutorial/examples/../../images/icons/step.svg" alt="Step" />), the content from <code>IN</code> should appear in the register <code>A</code>. Now the second factor can be written into <code>IN</code> and by clicking again on step (<img src="tutorial/examples/../../images/icons/step.svg" alt="Step" />) it is transferred into <code>FACTOR</code>.</p>
<p>With these values the program can now be run by clicking on run (<img src="tutorial/examples/../../images/icons/run.svg" alt="Run" />). After the calculation is finished, the result of the multiplication is shown in the output <code>OUT</code>.
If you want to follow the multiplication in detail, you can click step (<img src="tutorial/examples/../../images/icons/step.svg" alt="Step" />) or micro step (<img src="tutorial/examples/../../images/icons/micro-step.svg" alt="Micro Step" />) to follow each step of the program.</p>
<p>You can now reset the program via reset (<img src="tutorial/examples/../../images/icons/reset.svg" alt="Reset" />) and try another simulation with new values. For changes to the program text you can return to the editing mode via the edit button (<img src="tutorial/examples/../../images/icons/code.svg" alt="Code" />).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="register-register-machine"><a class="header" href="#register-register-machine">Register-Register-Machine</a></h1>
<h2 id="task-1"><a class="header" href="#task-1">Task</a></h2>
<p><img src="tutorial/examples/../../images/rrm-block-diagram.png" alt="Block Diagram" /></p>
<p>Using the above block diagram, a simple processor is to be realized. For this a register array is to be used to manage the 8-bit source and destination registers. Via the shown data path instructions and data are loaded from the memory into the instruction register <em>IR</em>. The instruction format is given as follows:</p>
<p><img src="tutorial/examples/../../images/rrm-instruction-format.png" alt="Instruction Format" /></p>
<p>Each instruction consists of at least one byte. For jump instructions a second byte with the destination address is needed. The source and destination registers of the register array <em>Rm</em> and <em>Rn</em> are specified via two 2-bit wide numbers. A 4 bit wide number encodes the instruction to be executed. The processor has the following instructions for unsigned numbers:</p>
<table><thead><tr><th>Instruction</th><th>Opcode</th><th>Description</th></tr></thead><tbody>
<tr><td>ADD <em>Rm</em>, <em>Rn</em></td><td>0001</td><td>Adds <em>Rm</em> and <em>Rn</em>, result in <em>Rm</em></td></tr>
<tr><td>SHL <em>Rm</em></td><td>0010</td><td>Shifts <em>Rm</em> by one bit to the left and sets the vacant bit to 0</td></tr>
<tr><td>LOAD <em>Rm</em></td><td>0011</td><td>Loads <em>Rm</em> with the memory contents specified by <em>R3</em></td></tr>
<tr><td>STORE <em>Rm</em></td><td>0100</td><td>Writes <em>Rm</em> to the memory location specified in <em>R3</em></td></tr>
<tr><td>JMP address</td><td>0101</td><td>Continues the program execution at <em>address</em></td></tr>
<tr><td>BREQ address</td><td>0110</td><td>Continues the program execution at <em>address</em> if the result of the last result of the last operation was 0</td></tr>
</tbody></table>
<p>The arithmetic logic unit (ALU) does not consider overflows, which means that in this case only the lower 8 bits of the result are output. To be able to execute the BREQ instruction more easily, the ALU has an additional flag <em>Z</em>, which takes the value value 1 if the result of the last operation was 0. Otherwise Z is set to 0.</p>
<h2 id="draft-program-1"><a class="header" href="#draft-program-1">Draft Program</a></h2>
<p>First you can see from the block diagram which registers, memories and register arrays are needed:</p>
<pre><code class="language-rteasy">declare register IR(7:0), AR(7:0), DR(7:0), PC(7:0), Z
declare register array R(7:0)[4]
declare memory MEM(AR, DR)
</code></pre>
<p>Next, the registers that are read from at the beginning should be initialized with 0. Since one reads an instruction from the memory first, <code>PC</code> and <code>AR</code> should be initialized. This can be done under a label <code>INIT</code> for the sake of clarity:</p>
<pre><code class="language-rteasy"><span class="boring">declare register IR(7:0), AR(7:0), DR(7:0), PC(7:0), Z
</span><span class="boring">declare register array R(7:0)[4]
</span><span class="boring">declare memory MEM(AR, DR)
</span><span class="boring">
</span>INIT:
    PC &lt;- 0, AR &lt;- 0;
</code></pre>
<p>With the declaration and initialization completed, the first program step follows, the fetching of instructions from memory, whereby the incrementing of the program counter <code>PC</code> already prepares for the next instruction:</p>
<pre><code class="language-rteasy"><span class="boring">declare register IR(7:0), AR(7:0), DR(7:0), PC(7:0), Z
</span><span class="boring">declare register array R(7:0)[4]
</span><span class="boring">declare memory MEM(AR, DR)
</span><span class="boring">
</span><span class="boring">INIT:
</span><span class="boring">    PC &lt;- 0, AR &lt;- 0;
</span><span class="boring">
</span>FETCH:
    AR &lt;- PC;
    PC &lt;- PC + 1, read MEM;
</code></pre>
<p>Now the instruction must go into <code>IR</code>, where it is processed. For this purpose a switch case is used, which compares the upper 4 bits of the instruction stored in <code>IR</code> to the values 0 to 6 and jumps to the label where the respective instruction is executed in case of a match:</p>
<!-- compile_fail(E006) since goto labels are not yet defined -->
<pre><code class="language-rteasy compile_fail(E006)"><span class="boring">declare register IR(7:0), AR(7:0), DR(7:0), PC(7:0), Z
</span><span class="boring">declare register array R(7:0)[4]
</span><span class="boring">declare memory MEM(AR, DR)
</span><span class="boring">
</span><span class="boring">INIT:
</span><span class="boring">    PC &lt;- 0, AR &lt;- 0;
</span><span class="boring">
</span><span class="boring">FETCH:
</span><span class="boring">    AR &lt;- PC;
</span><span class="boring">    PC &lt;- PC + 1, read MEM;
</span><span class="boring">
</span>    IR &lt;- DR | switch IR(7:4) {
        case 0: goto FETCH
        case 1: goto ADD
        case 2: goto SHL
        case 3: goto LOAD
        case 4: goto STORE
        case 5: goto JMP
        case 6: goto BREQ
        default: goto END
    };
</code></pre>
<p>The instruction executions follow:</p>
<pre><code class="language-rteasy"><span class="boring">declare register IR(7:0), AR(7:0), DR(7:0), PC(7:0), Z
</span><span class="boring">declare register array R(7:0)[4]
</span><span class="boring">declare memory MEM(AR, DR)
</span><span class="boring">
</span><span class="boring">INIT:
</span><span class="boring">    PC &lt;- 0, AR &lt;- 0;
</span><span class="boring">
</span><span class="boring">FETCH:
</span><span class="boring">    AR &lt;- PC;
</span><span class="boring">    PC &lt;- PC + 1, read MEM;
</span><span class="boring">
</span><span class="boring">    IR &lt;- DR | switch IR(7:4) {
</span><span class="boring">        case 0: goto FETCH
</span><span class="boring">        case 1: goto ADD
</span><span class="boring">        case 2: goto SHL
</span><span class="boring">        case 3: goto LOAD
</span><span class="boring">        case 4: goto STORE
</span><span class="boring">        case 5: goto JMP
</span><span class="boring">        case 6: goto BREQ
</span><span class="boring">        default: goto END
</span><span class="boring">    };
</span><span class="boring">
</span>ADD:
    # Add Rm and Rn and write the result into Rm
    R[IR(3:2)] &lt;- R[IR(3:2)] + R[IR(1:0)];
    # If the result is 0, then set Z otherwise set Z to 0
    # and fetch the next instruction
    if R[IR(3:2)] = 0 then Z &lt;- 1 else Z &lt;- 0 fi, goto FETCH;

SHL:
    # Shift Rm by one bit to the left and set the vacant bit to 0
    R[IR(3:2)] &lt;- R[IR(3:2)](6:0).&quot;0&quot;;
    # If the result is 0, then set Z otherwise set Z to 0
    # and fetch the next instruction
    if R[IR(3:2)] = 0 then Z &lt;- 1 else Z &lt;- 0 fi, goto FETCH;

LOAD:
    # Write the content of R3 into the address register
    AR &lt;- R[3];
    # Read from memory
    read MEM;
    # Store the memory contents in the register array and fetch the next instruction
    R[IR(3:2)] &lt;- DR, goto FETCH;

STORE:
    # Write the content of R3 into the address register
    # and write Rm into the data register
    AR &lt;- R[3], DR &lt;- R[IR(3:2)];
    # Write the data into the memory and fetch the next instruction
    write MEM, goto FETCH;


JMP:
    # Get the jump address from the memory
    AR &lt;- PC;
    read MEM;
    # Set PC to this address and fetch the next instruction
    PC &lt;- DR | goto FETCH;

BREQ:
    # If Z is set then execute a jump (JMP),
    # otherwise continue in the program as usual (fetch the next instruction)
    if Z = 1 then goto JMP else goto FETCH fi;

END:
    # If undefined instructions occur, the program ends here
    nop;
</code></pre>
<p>The complete program should now look something like this:</p>
<pre><code class="language-rteasy">declare register IR(7:0), AR(7:0), DR(7:0), PC(7:0), Z
declare register array R(7:0)[4]
declare memory MEM(AR, DR)

INIT:
    PC &lt;- 0, AR &lt;- 0;

FETCH:
    AR &lt;- PC;
    PC &lt;- PC + 1, read MEM;

    IR &lt;- DR | switch IR(7:4) {
        case 0: goto FETCH
        case 1: goto ADD
        case 2: goto SHL
        case 3: goto LOAD
        case 4: goto STORE
        case 5: goto JMP
        case 6: goto BREQ
        default: goto END
    };

ADD:
    # Add Rm and Rn and write the result into Rm
    R[IR(3:2)] &lt;- R[IR(3:2)] + R[IR(1:0)];
    # If the result is 0, then set Z otherwise set Z to 0
    # and fetch the next instruction
    if R[IR(3:2)] = 0 then Z &lt;- 1 else Z &lt;- 0 fi, goto FETCH;

SHL:
    # Shift Rm by one bit to the left and set the vacant bit to 0
    R[IR(3:2)] &lt;- R[IR(3:2)](6:0).&quot;0&quot;;
    # If the result is 0, then set Z otherwise set Z to 0
    # and fetch the next instruction
    if R[IR(3:2)] = 0 then Z &lt;- 1 else Z &lt;- 0 fi, goto FETCH;

LOAD:
    # Write the content of R3 into the address register
    AR &lt;- R[3];
    # Read from memory
    read MEM;
    # Store the memory contents in the register array and fetch the next instruction
    R[IR(3:2)] &lt;- DR, goto FETCH;

STORE:
    # Write the content of R3 into the address register
    # and write Rm into the data register
    AR &lt;- R[3], DR &lt;- R[IR(3:2)];
    # Write the data into the memory and fetch the next instruction
    write MEM, goto FETCH;


JMP:
    # Write the content of PC into the address register
    AR &lt;- PC;
    # Get the jump address from the memory
    read MEM;
    # Set PC to this address and fetch the next instruction
    PC &lt;- DR | goto FETCH;

BREQ:
    # If Z is set then execute a jump (JMP),
    # otherwise continue in the program as usual (fetch the next instruction)
    if Z = 1 then goto JMP else goto FETCH fi;

END:
    # If undefined instructions occur, the program ends here
    nop;
</code></pre>
<h2 id="simulation-1"><a class="header" href="#simulation-1">Simulation</a></h2>
<p>To simulate the program, a memory content containing the instructions is necessary. For this you can download <a href="tutorial/examples/../../files/rrm-memory.rtmem">this memory file</a> (same as below). Then load it into <code>MEM</code> as shown <a href="tutorial/examples/../ide/simulation-mode.html#register-array-and-memory-view">here</a>.</p>
<pre><code class="language-rtmem">B 8 8

         # | Address | Opcode | m  | n  | Instruction |
         # | ------- | ------ | -- | -- | ----------- |
00110000 # | 0       | 0011   | 00 | 00 | LOAD Rm     |
00010100 # | 1       | 0001   | 01 | 00 | ADD Rm, Rn  |
00100100 # | 2       | 0010   | 01 | 00 | SHL Rm      |
01001000 # | 3       | 0100   | 10 | 00 | STORE Rm    |
01010000 # | 4       | 0101   | 00 | 00 | JMP address |
00000001 # | 5       | 0000   | 00 | 01 | -           |
01100000 # | 6       | 0110   | 00 | 00 | BREQ adress |
00000000 # | 7       | 0000   | 00 | 00 | -           |
</code></pre>
<p>After you have set up the memory, you can start simulating the program. The table below shows what effect the memory content should have.</p>
<table><thead><tr><th>Address</th><th>Description</th><th>Rm</th><th>Rn</th></tr></thead><tbody>
<tr><td>0</td><td>Load the value at address <code>R3</code> (= 0) into register array at position <em>m</em> (= 0)</td><td>00110000</td><td>x</td></tr>
<tr><td>1</td><td>Add register at position <em>m</em> (= 1) and at position <em>n</em> (= 0)</td><td>00110000</td><td>00110000</td></tr>
<tr><td>2</td><td>Shift register at position <em>m</em> (= 1) by 1 bit to the left</td><td>01100000</td><td>x</td></tr>
<tr><td>3</td><td>Write the value from register <em>m</em> (= 2) to the memory at address <code>R3</code></td><td>x</td><td>x</td></tr>
<tr><td>4</td><td>Jump to value from next address</td><td>x</td><td>x</td></tr>
<tr><td>5</td><td>Address to jump to</td><td>x</td><td>x</td></tr>
<tr><td>6</td><td>(should not be reached!) If <code>Z=1</code> jump to value from next address</td><td>x</td><td>x</td></tr>
<tr><td>7</td><td>Address to jump to</td><td>x</td><td>x</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced"><a class="header" href="#advanced">Advanced</a></h1>
<p>The following sections contain advanced/in-depth material.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="evaluation-of-expressions"><a class="header" href="#evaluation-of-expressions">Evaluation of Expressions</a></h1>
<p>This chapter describes in detail how expressions are evaluated. Starting with the local concepts of signedness and overflow behavior. Next, the precedence and associativity of operators is defined. The last section defines in which size expressions are evaluated in and how this is derived.</p>
<h2 id="signedness"><a class="header" href="#signedness">Signedness</a></h2>
<p>Signedness specifies whether a numeric data type can represent negative and positive numbers or only non-negative numbers. For example C has <code>unsigned int</code> and <code>signed int</code>.</p>
<p>RTeasy has no concept of signed variables or numbers. All operations always treat the operands as unsigned numbers.</p>
<p>Although there are no signed numbers, expressions like <code>-1</code> are still valid. This is possible because this is parsed as <code>neg 1</code> where <code>neg</code> is just the arithmetic negation operator.
This also fits well with how the size of expressions is calculated, as shown in <a href="tutorial/advanced/eval-expressions.html#expression-size-and-context-size">Expression Size and Context Size</a>.</p>
<p>For operations like add, subtract and negate there is nothing to consider, because they behave the same for signed and unsigned numbers in the 2's complement anyway. Care must be taken with comparisons. Since every number is always treated as unsigned, unexpected things can happen as seen in the following example:</p>
<pre><code class="language-rteasy"># The following assert will hold,
# because it is equivalent to 0b1111 &gt; 0b1100
assert -1 &gt; 12;
</code></pre>
<h2 id="overflow-behavior"><a class="header" href="#overflow-behavior">Overflow Behavior</a></h2>
<p>Arithmetic overflow can occur if the result of an operation is outside of the range of the value produced. Since registers and buses are sized in RTeasy this behavior can occur.</p>
<p>Overflow behavior affects only two operators in RTeasy: Addition and subtraction. These two arithmetic operations will always overflow and wrap, for example:</p>
<pre><code class="language-rteasy">declare register X(2:0) # 0b000 to 0b111, or 0 to 7
X &lt;- 0b100 + 0b101; # 4 + 5
assert X = 0b001; # X = 9 mod 8 = 1
</code></pre>
<h2 id="operator-precedence-and-associativity"><a class="header" href="#operator-precedence-and-associativity">Operator Precedence and Associativity</a></h2>
<p>Operator precedence and associativity forms the basis for how an expression is parsed. The following table gives an overview of all operators. Operators with higher precedence are executed before operators with lower precedence. Precedence comes before associativity.</p>
<table><thead><tr><th>Precedence</th><th>Operator</th><th>Associativity</th><th>Individual operators</th></tr></thead><tbody>
<tr><td>10</td><td>Unary Sign</td><td>right-to-left</td><td><code>- ... </code></td></tr>
<tr><td>10</td><td>Unary Negation</td><td>right-to-left</td><td><code>neg ... </code></td></tr>
<tr><td>9</td><td>Sign Extend</td><td>right-to-left</td><td><code>sxt ... </code></td></tr>
<tr><td>8</td><td>Addition</td><td>left-to-right</td><td><code>... + ...</code></td></tr>
<tr><td>8</td><td>Subtraction</td><td>left-to-right</td><td><code>... - ...</code></td></tr>
<tr><td>7</td><td>Less Than</td><td>left-to-right</td><td><code>... &lt; ...</code></td></tr>
<tr><td>7</td><td>Less Than Or Equal</td><td>left-to-right</td><td><code>... &lt;= ...</code></td></tr>
<tr><td>7</td><td>Greater Than</td><td>left-to-right</td><td><code>... &gt; ...</code></td></tr>
<tr><td>7</td><td>Greater Than Or Equal</td><td>left-to-right</td><td><code>... &gt;= ...</code></td></tr>
<tr><td>6</td><td>Equality</td><td>left-to-right</td><td><code>... = ...</code></td></tr>
<tr><td>6</td><td>Inequality</td><td>left-to-right</td><td><code>... &lt;&gt; ...</code></td></tr>
<tr><td>5</td><td>Bitwise NOT</td><td>right-to-left</td><td><code>not ...</code></td></tr>
<tr><td>4</td><td>Bitwise NAND</td><td>left-to-right</td><td><code>... nand ...</code></td></tr>
<tr><td>3</td><td>Bitwise AND</td><td>left-to-right</td><td><code>... and ...</code></td></tr>
<tr><td>2</td><td>Bitwise NOR</td><td>left-to-right</td><td><code>... nor ...</code></td></tr>
<tr><td>1</td><td>Bitwise OR</td><td>left-to-right</td><td><code>... or ...</code></td></tr>
<tr><td>0</td><td>Bitwise XOR</td><td>left-to-right</td><td><code>... xor ...</code></td></tr>
</tbody></table>
<h2 id="expression-size-and-context-size"><a class="header" href="#expression-size-and-context-size">Expression Size and Context Size</a></h2>
<p>At first glance it may seem that there is only one type in RTeasy: unsigned integer.
But in fact RTeasy considers the exact size of each expression. Thus, each possible size of an expression results in a different type. This raises the question what happens when two expressions with different sizes are added, for example.
In RTeasy there are no explicit casts, instead there are rules about which expression yields which size.</p>
<p>To determine the size there are actually two algorithms. One for calculating the (minimum) size of an expression and one for providing a size an expression will actually evaluate in.</p>
<h3 id="size"><a class="header" href="#size">Size</a></h3>
<p>The first algorithm runs at compile time. It annotates each expression with the calculated size. The algorithm operates bottom-up. The resulting size is used for two purposes: First, to check if an expression can fit into a target, e.g. a register. So an expression of size 7 can fit into an 8 bit wide register, but not into a 4 bit wide register. Second, the calculated size is needed for the second algorithm. The rules for calculating the size are specified in the following table:</p>
<table><thead><tr><th>Expression type</th><th>Size</th></tr></thead><tbody>
<tr><td>Register/Bus/Register Array</td><td>Size of bit range</td></tr>
<tr><td>Bit string literal</td><td>Amount of digits</td></tr>
<tr><td>Other literals</td><td>Size of shortest binary representation</td></tr>
<tr><td>Concatenation</td><td>Sum of the sizes of all subexpressions</td></tr>
<tr><td>Unary operators (-, neg, sxt, not)</td><td>Size of inner expression</td></tr>
<tr><td>Comparisons (&lt;, &lt;=, &gt;, &gt;=, =, &lt;&gt;)</td><td>1</td></tr>
<tr><td>Other binary operators (+, -, nand, and, nor, or, xor)</td><td>Maximum size of left and right expression</td></tr>
</tbody></table>
<h3 id="context-size"><a class="header" href="#context-size">Context Size</a></h3>
<p>The second algorithm runs at runtime in the case of the simulator. When generating hardware, it is part of the compiler instead. The algorithm operates top-down. The size calculated by the algorithm will be called &quot;context size&quot; in the following. An expression that is evaluated with the context size <em>n</em> always returns a result that is <em>n</em> bit wide.</p>
<p>For leaf expressions, like literals or registers, this is achieved by just zero extending the value to the context size. For unary/binary operations, like a comparison, this is achieved by zero extending the result of the operation, except for <code>sxt</code> where the result of the inner expression is sign extended.</p>
<p>The algorithm is used when executing assignments, if conditions and switch-case values. Depending on where it is used, the initial context size will vary. For assignments, the initial context size is equal to the size of the target. For if conditions the initial size is always one and for switch-case values it is equal to the size of the expression which it is matched against. The rules for passing down the context size are specified in the following table (Inherit means that the context size received is simply passed on):</p>
<table><thead><tr><th>Expression type</th><th>Passed down context size</th></tr></thead><tbody>
<tr><td>Register/Bus/Register Array</td><td>n/a</td></tr>
<tr><td>Literals</td><td>n/a</td></tr>
<tr><td>Concatenation</td><td>Each subexpression gets its own size</td></tr>
<tr><td>Sign Extend (sxt)</td><td>Size of inner expression</td></tr>
<tr><td>Other unary operators (-, neg, not)</td><td>Inherit</td></tr>
<tr><td>Comparisons (&lt;, &lt;=, &gt;, &gt;=, =, &lt;&gt;)</td><td>Maximum size of left and right expression</td></tr>
<tr><td>Other binary operators (+, -, nand, and, nor, or, xor</td><td>Inherit</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-file-format"><a class="header" href="#memory-file-format">Memory File Format</a></h1>
<p>The memory file format is a simple line-based file format.</p>
<h2 id="header"><a class="header" href="#header">Header</a></h2>
<p>The first line is the header, which indicates in which base the numbers are stored and how large the memory is. The header must always be in the following shape:</p>
<pre><code class="language-rtmem">[B|b|H|h] &lt;ADDRESS_SIZE&gt; &lt;DATA_SIZE&gt;
</code></pre>
<p><code>B</code> or <code>b</code> means binary, <code>H</code> or <code>h</code> means hexadecimal. <code>ADDRESS_SIZE</code> specifies the bit width of the address space and <code>DATA_SIZE</code> specifies the bit width of the data. For example, a memory that is stored in a binary base, with 65536 (= 2^16) entries and a width of 1 byte, has the following header:</p>
<pre><code class="language-rtmem">B 16 8
</code></pre>
<h2 id="data"><a class="header" href="#data">Data</a></h2>
<p>After the header, the data is stored line by line. The first line, unless otherwise specified, is at address 0. Subsequent lines are always located at the next address. For example, the following describes a memory with the numbers <code>0x1</code>, <code>0x7</code> and <code>0xF1</code> at address <code>0x0</code>, <code>0x1</code> and <code>0x2</code>:</p>
<pre><code class="language-rtmem">H 4 16

1
7
F1
</code></pre>
<p>Additionally, it is possible to store data at a specific address. With <code>&lt;ADDRESS&gt;:</code> the address for the next line can be specified. For example, in the following, the values <code>0xFF</code> and <code>0xC</code> are stored at the addresses <code>0x9</code> and <code>0xA</code>:</p>
<pre><code class="language-rtmem">H 4 16

9:
FF
C
</code></pre>
<p>Of course, this can be combined in any way:</p>
<pre><code class="language-rtmem">H 4 16

3
4

C:
2
1

3:
25
</code></pre>
<h2 id="comments"><a class="header" href="#comments">Comments</a></h2>
<p>The memory format allows simple line comments starting with the hash (#) character. Comments are allowed in all lines including the header. Example:</p>
<pre><code class="language-rtmem">H 8 32 # Memory in hexadecimal base

# Hello World

4: # Store some data, starting at address 4
FF # (addr = 4)
0  # (addr = 5)
1  # (addr = 6)
2  # (addr = 7)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="errors"><a class="header" href="#errors">Errors</a></h1>
<p>An overview of all possible errors that can occur during compilation.</p>
<h2 id="e001"><a class="header" href="#e001">E001</a></h2>
<p>This error indicates that a symbol is declared more than once.</p>
<h3 id="examples-1"><a class="header" href="#examples-1">Examples</a></h3>
<pre><code class="language-rteasy compile_fail(E001)">declare register X(3:0)
declare register X # error: duplicate symbol &quot;X&quot;
</code></pre>
<pre><code class="language-rteasy compile_fail(E001)">declare register X(3:0)
declare bus X # error: duplicate symbol &quot;X&quot;
</code></pre>
<h2 id="e002"><a class="header" href="#e002">E002</a></h2>
<p>This error indicates that the length of a register array is not a power of two. The length must always be a power of two.</p>
<h3 id="examples-2"><a class="header" href="#examples-2">Examples</a></h3>
<pre><code class="language-rteasy compile_fail(E002)"># error: length of register array &quot;ARR&quot; must be a power of two
declare register array ARR(7:0)[3]
</code></pre>
<pre><code class="language-rteasy compile_fail(E002)"># error: length of register array &quot;ARR&quot; must be a power of two
declare register array ARR(7:0)[0]
</code></pre>
<h2 id="e003"><a class="header" href="#e003">E003</a></h2>
<p>This error occurs when a register array is used without an index expression.</p>
<h3 id="examples-3"><a class="header" href="#examples-3">Examples</a></h3>
<pre><code class="language-rteasy compile_fail(E003)"><span class="boring">declare register X(7:0)
</span><span class="boring">declare register array ARR(7:0)[4]
</span><span class="boring">
</span>X &lt;- ARR[0] + 1; # ok
X &lt;- ARR + 1;    # error: register array &quot;ARR&quot; is missing index [...]
</code></pre>
<pre><code class="language-rteasy compile_fail(E003)"><span class="boring">declare register array ARR(7:0)[4]
</span><span class="boring">
</span>ARR[3] &lt;- 1 + 1; # ok
ARR &lt;- 1 + 1;    # error: register array &quot;ARR&quot; is missing index [...]
</code></pre>
<h2 id="e004"><a class="header" href="#e004">E004</a></h2>
<p>This error indicates that a label is declared more than once. Labels are used as goto marks and must therefore be unique.</p>
<h3 id="examples-4"><a class="header" href="#examples-4">Examples</a></h3>
<pre><code class="language-rteasy compile_fail(E004)"><span class="boring">declare register X(3:0), Y(3:0)
</span><span class="boring">
</span>MY_LABEL: X &lt;- Y;
MY_LABEL: X &lt;- X + 1; # error: duplicate label &quot;MY_LABEL&quot;
</code></pre>
<h2 id="e005"><a class="header" href="#e005">E005</a></h2>
<p>This error occurs when a symbol can not be found.</p>
<h3 id="examples-5"><a class="header" href="#examples-5">Examples</a></h3>
<pre><code class="language-rteasy compile_fail(E005)">declare register AR(3:0)
declare memory MEM(AR, DR) # error: no register named &quot;DR&quot; found
</code></pre>
<pre><code class="language-rteasy compile_fail(E005)">X &lt;- 42 + 2; # error: no register or bus named &quot;X&quot; found
</code></pre>
<pre><code class="language-rteasy compile_fail(E005)">declare register X(3:0)
X &lt;- ARR[0]; # error: no register array named &quot;ARR&quot; found
</code></pre>
<pre><code class="language-rteasy compile_fail(E005)">read MEM; # error: no memory named &quot;MEM&quot; found
</code></pre>
<h2 id="e006"><a class="header" href="#e006">E006</a></h2>
<p>This error occurs when a label can not be found.</p>
<h3 id="examples-6"><a class="header" href="#examples-6">Examples</a></h3>
<pre><code class="language-rteasy compile_fail(E006)">LABEL_A: goto LABEL_B; # error: no label named &quot;LABEL_B&quot; found
</code></pre>
<h2 id="e007"><a class="header" href="#e007">E007</a></h2>
<p>This error occurs when an expression without a fixed size is used in a switch operation. This requirement is necessary to have a well defined size in which to evaluate. Fixed size expression are: comparisons, concatenations, registers, buses, register arrays and bit strings.</p>
<h3 id="examples-7"><a class="header" href="#examples-7">Examples</a></h3>
<pre><code class="language-rteasy compile_fail(E007)"><span class="boring">declare register X(3:0), Y(3:0)
</span><span class="boring">
</span>switch X + Y { # error: expected fixed size expression
    case 1: nop
    default: nop
};
</code></pre>
<pre><code class="language-rteasy compile_fail(E007)">switch 12 { # error: expected fixed size expression
    case 1: nop
    default: nop
};
</code></pre>
<pre><code class="language-rteasy"><span class="boring">declare register X(3:0), Y(3:0)
</span><span class="boring">
</span>switch X = Y { # ok
    case 1: nop
    default: nop
};
</code></pre>
<pre><code class="language-rteasy">switch &quot;1100&quot; { # ok
    case 1: nop
    default: nop
};
</code></pre>
<h2 id="e008"><a class="header" href="#e008">E008</a></h2>
<p>This error occurs when a non-constant expression used in a case clause. Constant expression are: literals, concatenations only containing constants and terms only containing constants.</p>
<h3 id="examples-8"><a class="header" href="#examples-8">Examples</a></h3>
<pre><code class="language-rteasy compile_fail(E008)"><span class="boring">declare register X(3:0), Y(3:0)
</span><span class="boring">
</span>switch &quot;0101&quot; {
    case X + Y: nop # error: expected constant expression
    default: nop
};
</code></pre>
<pre><code class="language-rteasy">switch &quot;0101&quot; {
    case 7: nop # ok
    default: nop
};
</code></pre>
<pre><code class="language-rteasy">switch &quot;0101&quot; {
    case 3 + 4: nop # ok
    default: nop
};
</code></pre>
<h2 id="e009"><a class="header" href="#e009">E009</a></h2>
<p>This error indicates a switch operation with zero or more than one default clause. Switch operations must always have exactly one default clause.</p>
<h3 id="examples-9"><a class="header" href="#examples-9">Examples</a></h3>
<pre><code class="language-rteasy compile_fail(E009)"># error: expected exactly one default clause
switch &quot;0101&quot; {
    case 1: nop
};
</code></pre>
<pre><code class="language-rteasy compile_fail(E009)"># error: expected exactly one default clause
switch &quot;0101&quot; {
    case 1: nop
    default: nop
    default: nop
};
</code></pre>
<h2 id="e010"><a class="header" href="#e010">E010</a></h2>
<p>This error occurs when a literal other than the bit string is used in a concatenation. Concatenations may only contain elements of fixed size, thus only registers, buses, register arrays and bit strings.</p>
<h3 id="examples-10"><a class="header" href="#examples-10">Examples</a></h3>
<pre><code class="language-rteasy compile_fail(E010)"><span class="boring">declare register X(7:0), Y(3:0)
</span><span class="boring">
</span>X &lt;- Y.&quot;101&quot;.Y(0); # ok
X &lt;- Y.5.Y(0);     # error: concat must not contain numbers other than bit strings
</code></pre>
<h2 id="e011"><a class="header" href="#e011">E011</a></h2>
<p>This error occurs when the right-hand side of an assignment is wider than the target. Consider restricting the right-hand side to a smaller bit range or making the target wider.</p>
<h3 id="examples-11"><a class="header" href="#examples-11">Examples</a></h3>
<pre><code class="language-rteasy compile_fail(E011)">declare register X(7:0), Y(3:0)

X &lt;- Y;      # ok
Y &lt;- X(4:1); # ok
Y &lt;- X;      # error: right-hand side is too wide: 8 &gt; 4
</code></pre>
<h2 id="e012"><a class="header" href="#e012">E012</a></h2>
<p>This error occurs when the index expression of an register array is too wide. The size of the index must be less than or equal to <code>log2(arr_length)</code>, so that no invalid index can be used.</p>
<h3 id="examples-12"><a class="header" href="#examples-12">Examples</a></h3>
<pre><code class="language-rteasy compile_fail(E012)"><span class="boring">declare register X(7:0)
</span>declare register array ARR(7:0)[4]

X &lt;- ARR[0b01];  # ok
X &lt;- ARR[0b11];  # ok
X &lt;- ARR[0b100]; # error: index expression is too wide: 3 &gt; 2
</code></pre>
<h2 id="e013"><a class="header" href="#e013">E013</a></h2>
<p>This error occurs when the condition of an assert or if operation is not exactly one bit wide. A condition must always be either <code>0</code> or <code>1</code>.</p>
<h3 id="examples-13"><a class="header" href="#examples-13">Examples</a></h3>
<pre><code class="language-rteasy compile_fail(E013)">declare register X(7:0), Y(3:0)

# error: condition expression must be exactly one bit wide, but is: 8
assert X + Y;

# error: condition expression must be exactly one bit wide, but is: 4
if Y then nop fi;
</code></pre>
<pre><code class="language-rteasy"><span class="boring">declare register X(7:0), Y(3:0)
</span><span class="boring">
</span>assert X = Y;         # ok
if X = Y then nop fi; # ok
</code></pre>
<h2 id="e014"><a class="header" href="#e014">E014</a></h2>
<p>This error indicates that a bit range exceeds the maximum size. The maximum is <code>65536 = 2^16</code> by default. Address registers of memories are further limited to a size of <code>64 = 2^6</code>.</p>
<h3 id="examples-14"><a class="header" href="#examples-14">Examples</a></h3>
<pre><code class="language-rteasy compile_fail(E014)"># error: bit range size exceeds max size: 65538 &gt; 65536
declare bus B(0:65537)
</code></pre>
<pre><code class="language-rteasy compile_fail(E014)">declare register AR(128:32), DR(3:0)
declare memory MEM(AR, DR) # error: bit range size exceeds max size: 97 &gt; 64
</code></pre>
<h2 id="e015"><a class="header" href="#e015">E015</a></h2>
<p>This error occurs when a case value is wider than the expression being compared to. Consider making the expression wider or shrinking the case value.</p>
<h3 id="examples-15"><a class="header" href="#examples-15">Examples</a></h3>
<pre><code class="language-rteasy compile_fail(E015)">declare register X(3:0)

switch X {
    case 9: nop       # ok
    case &quot;1111&quot;: nop  # ok
    case &quot;10001&quot;: nop # error: case value is too wide: 5 &gt; 4
    default: nop
};
</code></pre>
<h2 id="e016"><a class="header" href="#e016">E016</a></h2>
<p>This error indicates a duplicate case value. Each case arm must have a unique value.</p>
<h3 id="examples-16"><a class="header" href="#examples-16">Examples</a></h3>
<pre><code class="language-rteasy compile_fail(E016)"><span class="boring">declare register X(3:0)
</span><span class="boring">
</span>switch X {
    case 3: nop     # ok
    case 2 + 1: nop # error: duplicate case value

    case 4: nop # ok
    case 4: nop # error: duplicate case value

    default: nop
};
</code></pre>
<h2 id="e017"><a class="header" href="#e017">E017</a></h2>
<p>This error indicates that the left-hand side of an assignment contains clocked and unclocked variables. Since they take on their new values at different times, it is not allowed to combine them on the left-hand side.</p>
<h3 id="examples-17"><a class="header" href="#examples-17">Examples</a></h3>
<pre><code class="language-rteasy compile_fail(E017)">declare register REG1(3:0), REG2(3:0)
declare bus BUS1(3:0), BUS2(3:0)

REG1.REG2 &lt;- 42; # ok
BUS1.BUS2 &lt;- 42; # ok

# error: the left-hand side of the assignment may contain either clocked or unclocked variables only
REG1.BUS1 &lt;- 42;
</code></pre>
<h2 id="e018"><a class="header" href="#e018">E018</a></h2>
<p>This error indicates that the left-hand side of an assignment contains non-variable items, such as bit strings.</p>
<h3 id="examples-18"><a class="header" href="#examples-18">Examples</a></h3>
<pre><code class="language-rteasy compile_fail(E018)"><span class="boring">declare register X(3:0), Y(3:0)
</span><span class="boring">
</span># error: the left-hand side of the assignment must be a variable
X.&quot;010&quot;.Y &lt;- X + Y;
</code></pre>
<h2 id="e019"><a class="header" href="#e019">E019</a></h2>
<p>This error indicates that the left-hand side of an assignment contains an input. Inputs are read-only and therefore cannot be assigned from within the program.</p>
<h3 id="examples-19"><a class="header" href="#examples-19">Examples</a></h3>
<pre><code class="language-rteasy compile_fail(E019)">declare input IN(7:0)
declare bus BUS(3:0)

IN &lt;- 12;    # error: cannot assign to input (inputs are read-only)
BUS.IN &lt;- 3; # error: cannot assign to input (inputs are read-only)
</code></pre>
<h2 id="e020"><a class="header" href="#e020">E020</a></h2>
<p>This error occurs when a used bit range exceeds the declaration. Bit ranges must specify a subrange of the declaration. Furthermore, they must also have the same &quot;direction&quot;, e.g. <code>(2:0)</code> is contained in <code>(3:0)</code>, but <strong>not</strong> in <code>(0:3)</code>.</p>
<h3 id="examples-20"><a class="header" href="#examples-20">Examples</a></h3>
<pre><code class="language-rteasy compile_fail(E020)">declare register X(7:0), Y(0:3)

X &lt;- X(6:2); # ok
X &lt;- X(15);  # error: bit range (15) exceeds declaration (7:0)

Y &lt;- Y(1:1); # ok
Y &lt;- Y(2:0); # error: bit range (2:0) exceeds declaration (0:3)
</code></pre>
<h2 id="e021"><a class="header" href="#e021">E021</a></h2>
<p>This error occurs when a goto operation is used before the pipe. If a statement uses the pipe operator and thus the conditional branch, all gotos must be placed after the pipe.</p>
<h3 id="examples-21"><a class="header" href="#examples-21">Examples</a></h3>
<pre><code class="language-rteasy compile_fail(E021)"><span class="boring">declare register X(7:0)
</span><span class="boring">
</span># ok, since this statement has no conditional branch
goto L1;

# error: no goto operations are allowed before pipe (&quot;|&quot;)
goto L1 | if X = 0 then goto L2 fi;
<span class="boring">
</span><span class="boring">L1: nop;
</span><span class="boring">L2: nop;
</span></code></pre>
<h2 id="e022"><a class="header" href="#e022">E022</a></h2>
<p>This error occurs when mutating operations are used after the pipe. After the pipe only conditional (if/switch), nop and assert operations are allowed.</p>
<h3 id="examples-22"><a class="header" href="#examples-22">Examples</a></h3>
<pre><code class="language-rteasy compile_fail(E022)"><span class="boring">declare register X(7:0)
</span><span class="boring">
</span># error: no mutating operations allowed after pipe (&quot;|&quot;)
nop | X &lt;- 12;
</code></pre>
<pre><code class="language-rteasy"><span class="boring">declare register X(7:0)
</span><span class="boring">
</span><span class="boring">START:
</span>X &lt;- 2 + 2 | assert X = 4;         # ok
nop | if X = 5 then goto START fi; # ok
</code></pre>
<h2 id="e023"><a class="header" href="#e023">E023</a></h2>
<p>This error occurs when a sign extend operator is used on a term. The sign extend operator may only be applied on simple expressions, like registers, buses or concatenations.</p>
<h3 id="examples-23"><a class="header" href="#examples-23">Examples</a></h3>
<pre><code class="language-rteasy compile_fail(E023)"><span class="boring">declare register X(7:0), Y(3:0)
</span><span class="boring">
</span>X &lt;- sxt Y;       # ok
X &lt;- sxt (Y + 1); # error: sxt operator is not supported for terms
</code></pre>
<h2 id="e024"><a class="header" href="#e024">E024</a></h2>
<p>This error occurs when a symbol can be found but is of the wrong type. For example, a memory is always expected in a read operation.</p>
<h3 id="examples-24"><a class="header" href="#examples-24">Examples</a></h3>
<pre><code class="language-rteasy compile_fail(E024)">declare register X(7:0), Y(3:0)
declare memory MEM(X, Y)

read X;   # error: expected memory, found: register
MEM &lt;- 2; # error: expected register or bus, found: memory
</code></pre>
<h2 id="e025"><a class="header" href="#e025">E025</a></h2>
<p>This error indicates that a register, bus, register array or memory is assigned more than once in a cycle. Only one assignment to an item may be executed per execution path and cycle.</p>
<h3 id="examples-25"><a class="header" href="#examples-25">Examples</a></h3>
<pre><code class="language-rteasy compile_fail(E025)"><span class="boring">declare register X(3:0)
</span><span class="boring">
</span>X &lt;- 2, X &lt;- 1; # error: register &quot;X&quot; is assigned more than once
</code></pre>
<pre><code class="language-rteasy compile_fail(E025)"><span class="boring">declare register AR(3:0), DR(3:0)
</span><span class="boring">declare memory MEM(AR, DR)
</span><span class="boring">
</span>read MEM, read MEM; # error: register &quot;DR&quot; is assigned more than once
write MEM, write MEM; # error: memory &quot;MEM&quot; is assigned more than once
</code></pre>
<pre><code class="language-rteasy"><span class="boring">declare register X(3:0), COND
</span><span class="boring">
</span># ok, because always only one of the two assignments is executed in one cycle
if COND then X &lt;- 2 else X &lt;- 1 fi;
</code></pre>
<h2 id="e026"><a class="header" href="#e026">E026</a></h2>
<p>This error indicates that a statement contains multiple gotos on at least one possible execution path. Only one goto may be executed per execution path and cycle.</p>
<h3 id="examples-26"><a class="header" href="#examples-26">Examples</a></h3>
<pre><code class="language-rteasy compile_fail(E026)"># error: statement contains multiple gotos on at least one possible execution path
goto L1, goto L2;
<span class="boring">
</span><span class="boring">L1: nop;
</span><span class="boring">L2: nop;
</span></code></pre>
<pre><code class="language-rteasy compile_fail(E026)"><span class="boring">declare register COND
</span><span class="boring">
</span># error: statement contains multiple gotos on at least one possible execution path
goto L1, if COND then goto L2 fi;
<span class="boring">
</span><span class="boring">L1: nop;
</span><span class="boring">L2: nop;
</span></code></pre>
<pre><code class="language-rteasy"><span class="boring">declare register COND
</span><span class="boring">
</span># ok, because always only one of the gotos is executed in one cycle
if COND then goto L1 else goto L2 fi;
<span class="boring">
</span><span class="boring">L1: nop;
</span><span class="boring">L2: nop;
</span></code></pre>
<h2 id="e027"><a class="header" href="#e027">E027</a></h2>
<p>This error indicates that a register array is read more than 2 times on at least one possible execution path. Only 2 read ports are available per register array and cycle.</p>
<h3 id="examples-27"><a class="header" href="#examples-27">Examples</a></h3>
<pre><code class="language-rteasy compile_fail(E027)"><span class="boring">declare register X(7:0)
</span><span class="boring">declare register array ARR(3:0)[4]
</span><span class="boring">
</span># error: register array &quot;ARR&quot; is read more than 2 times
X &lt;- ARR[0] + ARR[1] + ARR[2];

# error: register array &quot;ARR&quot; is read more than 2 times
X &lt;- ARR[1] + ARR[1] + ARR[1];
</code></pre>
<pre><code class="language-rteasy"><span class="boring">declare register X(7:0), COND
</span><span class="boring">declare register array ARR(3:0)[4]
</span><span class="boring">
</span># ok, since the register array is read at most twice
if COND then X &lt;- ARR[0] else X &lt;- ARR[1] + ARR[2] fi;
</code></pre>
<h2 id="e028"><a class="header" href="#e028">E028</a></h2>
<p>This error indicates that a statement has a feeback loop. This can happen, for example, when the value of a bus A depends on a bus B, and B in turn depends on A.</p>
<h3 id="examples-28"><a class="header" href="#examples-28">Examples</a></h3>
<pre><code class="language-rteasy compile_fail(E028)">declare bus A, B

# error: statement has a feedback loop
# (A depends on B and B depends on A)
A &lt;- B, B &lt;- A;
</code></pre>
<pre><code class="language-rteasy compile_fail(E028)">declare bus A, B

# error: statement has a feedback loop
# (A depends on itself)
if A then A &lt;- B fi;
</code></pre>
<h2 id="e029"><a class="header" href="#e029">E029</a></h2>
<p>This error occurs when a register array is used with a bit range on the left-hand side of an assignment. With register arrays it is only possible to access individual bits when reading.</p>
<p>The access to a register in an array is always exhaustive. When writing all bits must be written and when reading all bits must be read. Since single bits can be simply ignored when reading, it is possible to specify a bit range when reading.</p>
<h3 id="examples-29"><a class="header" href="#examples-29">Examples</a></h3>
<pre><code class="language-rteasy compile_fail(E029)"><span class="boring">declare register X(3:0)
</span><span class="boring">declare register array ARR(7:0)[4]
</span><span class="boring">
</span>X &lt;- ARR[2](3:0); # ok

ARR[2](3:0) &lt;- X; # error: bit range is not allowed in this position
</code></pre>
<h2 id="e200"><a class="header" href="#e200">E200</a></h2>
<p><em>(VHDL Export only)</em></p>
<p>This error indicates that a goto operation before the pipe operator is executed conditionally depending on a bus. The gotos are transformed to a state machine during the VHDL export. A dependency of the next state on an unclocked element is not possible with this.</p>
<p>This can be solved by moving the goto operation(s) after the pipe, but beware: this might change the semantics of the program! For example in the code below if we move <code>if BUS = 2 then goto END fi</code> after the pipe, this will change the semantics. Before the pipe <code>BUS</code> gets the old value of <code>X</code> (3), and after the pipe <code>BUS</code> gets the new value of <code>X</code> (2).</p>
<h3 id="examples-30"><a class="header" href="#examples-30">Examples</a></h3>
<pre><code class="language-rteasy vhdl_fail(E200)">declare register X(7:0)
declare bus BUS(7:0)

X &lt;- 3;
BUS &lt;- X, X &lt;- 2, if BUS = 2 then goto END fi; # error: next state depends on an unclocked item
X &lt;- X + 42;
END:
</code></pre>
<h2 id="e201"><a class="header" href="#e201">E201</a></h2>
<p><em>(VHDL Export only)</em></p>
<p>This error indicates that the first state contains a conditional goto operation before the pipe operator. The gotos are transformed to a state machine during the VHDL export. For this transformation it is not possible that the first state contains a goto before the pipe operator.</p>
<p>If it is not possible to get rid of the conditional goto, there are two possible solutions: First, by simply inserting an empty state before the first state (<code>nop;</code>). And second, by moving the goto operation(s) after the pipe, but beware: this might changes the semantics of the program if the registers have different values after the pipe!</p>
<h3 id="examples-31"><a class="header" href="#examples-31">Examples</a></h3>
<pre><code class="language-rteasy vhdl_fail(E201)">declare register X(3:0)

if X(0) then goto SKIP fi; # error: conditional goto in first state
X &lt;- 4;
SKIP: X &lt;- X + 1;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix"><a class="header" href="#appendix">Appendix</a></h1>
<h2 id="literature"><a class="header" href="#literature">Literature</a></h2>
<p>[1] Hagen Schendel, Carsten Albrecht, Erik Maehle. RTeasy: An Algorithmic Design Environment on Register Transfer Level. In WCAE 04: Proceedings of the 2004 Workshop on Computer Architecture Education, pages 2935, New York, NY, USA, June 2004. ACM.</p>
<p>[2] Christian Friedrich. Porting RTeasy to the NetBeans Platform. In: 2014.</p>
<p>[3] Jannik Obermann. RTeasy-Online  A Redesign and Extension of RTeasy2. In: 2022.</p>
<h2 id="credits"><a class="header" href="#credits">Credits</a></h2>
<p>Large parts of the tutorial, especially the application examples, are based on the previous version of the <a href="https://www.iti.uni-luebeck.de/fileadmin/Lehre/RTeasy/Tutorial.pdf">RTeasy Tutorial (2012)</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
