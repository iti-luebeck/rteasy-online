// Ast
pub ast -> Ast<'s>:
    many0(declaration) many0(statement) opt(terminated(label, ":")) eoi {
        Ast { declarations: $1, statements: $2, trailing_label: $3 }
    };

// Declarations
declaration -> Declaration<'s>:
      declare_register_array { Declaration::RegisterArray($1) }
    | declare_register { Declaration::Register($1) }
    | declare_bus { Declaration::Bus($1) }
    | declare_memory { Declaration::Memory($1) };
declare_register_array -> DeclareRegisterArray<'s>:
    "declare" "register" "array" sep1(declare_register_array_item, ",") { DeclareRegisterArray { register_arrays: $4 } };
declare_register -> DeclareRegister<'s>:
    "declare" "register" sep1(reg_bus, ",") { DeclareRegister { registers: $3, span: $span } };
declare_bus -> DeclareBus<'s>:
    "declare" "bus" sep1(reg_bus, ",") { DeclareBus { buses: $3 } };
declare_memory -> DeclareMemory<'s>:
    "declare" "memory" sep1(memory, ",") { DeclareMemory { memories: $3 } };

declare_register_array_item -> DeclareRegisterArrayItem<'s>:
    ident opt(bit_range) "[" number_usize "]" { DeclareRegisterArrayItem { ident: $1, range: $2, len: $4 } };

// Statement
statement -> Statement<'s>:
    opt(terminated(label, ":")) operations opt(preceded("|", operations)) ";" {
        Statement { label: $1, operations: $2, operations_post: $3, span: $span }
    };

// Operations
nop -> Nop: "nop" { Nop }; 
goto -> Goto<'s>: "goto" label { Goto { label: $2 } };
write -> Write<'s>: "write" ident { Write { ident: $2 } };
read -> Read<'s>: "read" ident { Read { ident: $2 } };
if_ -> If<'s>:
    "if" expression
    "then" operations
    opt(preceded("else", operations))
    "fi" { If { condition: $2, operations_if: $4, operations_else: $5 } };
switch -> Switch<'s>:
    "switch" expression "{" many0(either(case_clause, default_clause)) "}" {
        Switch { expression: $2, clauses: $4 }
    };
case_clause -> CaseClause<'s>: "case" expression ":" operations { CaseClause { value: $2, operations: $4 } };
default_clause -> DefaultClause<'s>: "default" ":" operations { DefaultClause { operations: $3 } };
lvalue -> Lvalue<'s>:
      concat { Lvalue::Concat($1) }
    | register_array { Lvalue::RegisterArray($1) }
    | reg_bus { Lvalue::RegBus($1) };
assignment -> Assignment<'s>: lvalue "<-" expression { Assignment { lhs: $1, rhs: $3 } };

operation -> Operation<'s>: operation_kind { Operation { kind: $1, span: $span } };
operation_kind -> OperationKind<'s>:
      nop { OperationKind::Nop($1) } | goto { OperationKind::Goto($1) }
    | write { OperationKind::Write($1) } | read { OperationKind::Read($1) }
    | if_ { OperationKind::If($1) } | switch { OperationKind::Switch($1) }
    | assignment { OperationKind::Assignment($1) };
operations -> Vec<Operation<'s>>: sep1(operation, ",") { $1 };

// Expression, TODO: ...
expression -> Expression<'s>:
      expression_not "xor" expression {
        BinaryTerm { lhs: $1, rhs: $3, operator: BinaryOperator::Xor }.into()
      }
    | expression_not { $1 };

expression_not -> Expression<'s>:
      "not" expression_not {
        UnaryTerm { expression: $2, operator: UnaryOperator::Not }.into()
      }
    | expression_cmp { $1 };

expression_cmp -> Expression<'s>:
      expression_plus "=" expression_plus {
        BinaryTerm { lhs: $1, rhs: $3, operator: BinaryOperator::Eq }.into()
      }
    | expression_plus "<>" expression_plus {
        BinaryTerm { lhs: $1, rhs: $3, operator: BinaryOperator::Ne }.into()
      }
    | expression_plus { $1 };

expression_plus -> Expression<'s>:
      expression_sxt "+" expression_plus {
        BinaryTerm { lhs: $1, rhs: $3, operator: BinaryOperator::Add }.into()
      }
    | expression_sxt "-" expression_plus {
        BinaryTerm { lhs: $1, rhs: $3, operator: BinaryOperator::Sub }.into()
      }
    | expression_sxt { $1 };

expression_sxt -> Expression<'s>:
      "sxt" expression_sxt {
        UnaryTerm { expression: $2, operator: UnaryOperator::Sxt }.into()
      }
    | expression_sign_neg { $1 };

expression_sign_neg -> Expression<'s>:
      either("-", "neg") expression_sign_neg {
        UnaryTerm { expression: $2, operator: UnaryOperator::SignNeg }.into()
      }
    | expression_leaf { $1 };

expression_leaf -> Expression<'s>:
      "(" expression ")" { $2 }
    | concat { Atom::Concat($1).into() }
    | register_array { Atom::RegisterArray($1).into() }
    | reg_bus { Atom::RegBus($1).into() }
    | number { Atom::Number($1).into() };

// ...
memory -> Memory<'s>: ident memory_range { Memory { ident: $1, range: $2 } };
reg_bus -> RegBus<'s>: ident opt(bit_range) { RegBus { ident: $1, range: $2 } };
register_array -> RegisterArray<'s>: ident "[" expression "]" { RegisterArray { ident: $1, index: Box::new($3) } };
concat -> Concat<'s>:
    concat_part many1(preceded(".", concat_part)) {
        let mut parts = $2;
        parts.insert(0, $1);
        Concat { parts }
    };
concat_part -> ConcatPart<'s>:
      register_array { ConcatPart::RegisterArray($1) }
    | reg_bus { ConcatPart::RegBus($1) }
    | number { ConcatPart::Number($1) };

// Common rules
bit_range -> BitRange:
      "(" number_usize ":" number_usize ")" { BitRange { msb: $2, lsb: Some($4) } }
    | "(" number_usize ")" { BitRange { msb: $2, lsb: None } };
memory_range -> MemoryRange<'s>:
    "(" ident "," ident ")" { MemoryRange { address_register: $2, data_register: $4 } };

// Number rules
number_usize -> usize: exact(Token::LiteralNumberDec) { parse_usize($1, $span) }?;
number_bin -> Number: exact(Token::LiteralNumberBin) { parse_bin($1, $span) }?;
number_dec -> Number: exact(Token::LiteralNumberDec) { parse_dec($1, $span) }?;
number_hex -> Number: exact(Token::LiteralNumberHex) { parse_hex($1, $span) }?;
number_bit_string -> Number: exact(Token::LiteralNumberBitString) { parse_bit_string($1, $span) }?;
number -> Number:
      number_bin { $1 }
    | number_dec { $1 }
    | number_hex { $1 }
    | number_bit_string { $1 };

// Ident/Label
ident -> Ident<'s>: exact(Token::Identifier) { Ident($1) };
label -> Label<'s>: exact(Token::Identifier) { Label($1) };

+++

// Token shortcuts

";" = Token::Semicolon
":" = Token::Colon
"," = Token::Comma
"|" = Token::Pipe
"." = Token::Dot
"(" = Token::ParenOpen
")" = Token::ParenClose
"[" = Token::BracketOpen
"]" = Token::BracketClose
"{" = Token::BraceOpen
"}" = Token::BraceClose
"<-" = Token::Assign
"quote" = Token::Quote

"declare" = Token::KeywordDeclare
"register" = Token::KeywordRegister
"bus" = Token::KeywordBus
"memory" = Token::KeywordMemory
"array" = Token::KeywordArray
"nop" = Token::KeywordNop
"goto" = Token::KeywordGoto
"read" = Token::KeywordRead
"write" = Token::KeywordWrite
"if" = Token::KeywordIf
"then" = Token::KeywordThen
"else" = Token::KeywordElse
"fi" = Token::KeywordFi
"switch" = Token::KeywordSwitch
"case" = Token::KeywordCase
"default" = Token::KeywordDefault

"=" = Token::OperatorEquality
"<>" = Token::OperatorInequality
"+" = Token::OperatorAddition
"-" = Token::OperatorSubtraction
"xor" = Token::OperatorXor
"neg" = Token::OperatorNeg
"not" = Token::OperatorNot
"sxt" = Token::OperatorSxt

+++

use rtcore::{ast::*, value::Value};
use crate::lexer::Token;
use toktok::combinator::{sep1, eoi, many0, many1, exact, opt, preceded, terminated, either};
use toktok::Error;
use std::ops::Range;

type Result<T> = std::result::Result<T, Error<Token>>;

fn parse_bin(s: &str, span: Range<usize>) -> Result<Number> {
    let s = &s[2..]; // TODO: Check if s begins with 0b/0B/%
    match Value::parse_bin(s, true) {
        Ok(value) => Ok(Number { value, kind: NumberKind::Other }),
        Err(()) => Err(Error::new_custom(span, "invalid binary number".into())),
    }
}

fn parse_dec(s: &str, span: Range<usize>) -> Result<Number> {
    match Value::parse_dec(s) {
        Ok(value) => Ok(Number { value, kind: NumberKind::Other }),
        Err(()) => Err(Error::new_custom(span, "invalid decimal number".into())),
    }
}

fn parse_hex(s: &str, span: Range<usize>) -> Result<Number> {
    let s = &s[2..]; // TODO: Check if s begins with 0x/0X/$
    match Value::parse_hex(s, true) {
        Ok(value) => Ok(Number { value, kind: NumberKind::Other }),
        Err(()) => Err(Error::new_custom(span, "invalid hexadecimal number".into())),
    }
}

fn parse_usize(s: &str, span: Range<usize>) -> Result<usize> {
    match s.parse() {
        Ok(value) => Ok(value),
        Err(_) => Err(Error::new_custom(span, "invalid number".into())),
    }
}

fn parse_bit_string(s: &str, span: Range<usize>) -> Result<Number> {
    let s = &s[1..s.len() - 1];
    match Value::parse_bin(s, false) {
        Ok(value) => Ok(Number { value, kind: NumberKind::BitString }),
        Err(()) => Err(Error::new_custom(span, "invalid bit string".into())),
    }
}